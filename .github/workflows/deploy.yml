name: Deploy to Azure

on:
  push:
    branches: [ main, production ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  NODE_VERSION: '20.x'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run security audit
      run: npm audit --audit-level=high
      continue-on-error: true
      
    - name: Run tests
      run: npm test
      continue-on-error: true
      
    - name: Run linting
      run: npm run lint
      
    - name: Type checking
      run: npm run typecheck
      
    - name: Build application
      run: npm run build
      
    - name: Create deployment package
      run: |
        echo "Creating deployment package..."
        
        # Validate required files exist
        if [ ! -d "dist" ]; then
          echo "::error::dist directory not found - build may have failed"
          exit 1
        fi
        
        if [ ! -f "package.json" ]; then
          echo "::error::package.json not found"
          exit 1
        fi
        
        if [ ! -f "package-lock.json" ]; then
          echo "::error::package-lock.json not found"
          exit 1
        fi
        
        
        # Verify critical files in dist directory
        if [ ! -f "dist/src/teams/index.js" ]; then
          echo "::error::Main application file dist/src/teams/index.js not found"
          exit 1
        fi
        
        # Create deployment package with node_modules
        echo "Packaging files: dist, package.json, package-lock.json, node_modules"
        zip -r deploy.zip dist package.json package-lock.json node_modules
        
        # Verify package was created
        if [ ! -f "deploy.zip" ]; then
          echo "::error::Failed to create deployment package"
          exit 1
        fi
        
        # Show package contents for verification
        echo "Deployment package contents:"
        unzip -l deploy.zip | head -20
        
        PACKAGE_SIZE=$(stat -c%s "deploy.zip" 2>/dev/null || stat -f%z "deploy.zip" 2>/dev/null || echo "unknown")
        echo "Package size: $PACKAGE_SIZE bytes"
        
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package
        path: deploy.zip

  deploy-to-staging:
    if: github.event_name == 'pull_request'
    needs: build-and-test
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://workbook-teams-bot-staging.azurewebsites.net
    
    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-package
        
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Deploy to staging
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ vars.AZURE_WEBAPP_NAME }}-staging
        package: deploy.zip
        
    - name: Health check
      run: |
        sleep 30
        curl -f https://${{ vars.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net/health || exit 1

  deploy-to-production:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: build-and-test
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://workbook-teams-bot.azurewebsites.net
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-package
        
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ vars.RESOURCE_GROUP }} \
          --location westeurope
        
    - name: Deploy Azure Infrastructure
      run: |
        echo "Starting ARM template deployment..."
        
        # Get current service principal object ID for Key Vault access
        CURRENT_PRINCIPAL_ID=$(az ad signed-in-user show --query id --output tsv 2>/dev/null || \
                              az account show --query user.name --output tsv | xargs az ad sp show --id | jq -r .id 2>/dev/null || \
                              echo "")
        
        echo "Service Principal ID: $CURRENT_PRINCIPAL_ID"
        
        # Run deployment with full JSON output for error diagnostics
        DEPLOYMENT_RESULT=$(az deployment group create \
          --resource-group ${{ vars.RESOURCE_GROUP }} \
          --template-file deployment/azure-deploy.json \
          --parameters \
            appServiceName=${{ vars.AZURE_WEBAPP_NAME }} \
            keyVaultName=${{ vars.KEY_VAULT_NAME }} \
            botAppId=${{ secrets.MICROSOFT_APP_ID }} \
            botAppPassword=${{ secrets.MICROSOFT_APP_PASSWORD }} \
            deploymentPrincipalId="$CURRENT_PRINCIPAL_ID" \
          --output json)
        
        # Extract deployment status
        DEPLOYMENT_STATUS=$(echo "$DEPLOYMENT_RESULT" | jq -r '.properties.provisioningState // "Unknown"')
        
        echo "Deployment Status: $DEPLOYMENT_STATUS"
        
        if [ "$DEPLOYMENT_STATUS" != "Succeeded" ]; then
          echo "::error::ARM deployment failed with status: $DEPLOYMENT_STATUS"
          
          # Extract detailed error information
          ERROR_CODE=$(echo "$DEPLOYMENT_RESULT" | jq -r '.properties.error.code // "N/A"')
          ERROR_MESSAGE=$(echo "$DEPLOYMENT_RESULT" | jq -r '.properties.error.message // "N/A"')
          
          echo "::error::Error Code: $ERROR_CODE"
          echo "::error::Error Message: $ERROR_MESSAGE"
          
          # Check for specific resource deployment failures
          echo "Checking individual resource deployment status..."
          az deployment operation group list \
            --resource-group ${{ vars.RESOURCE_GROUP }} \
            --name $(echo "$DEPLOYMENT_RESULT" | jq -r '.name') \
            --query "[?properties.provisioningState=='Failed'].{resource:properties.targetResource.resourceName,type:properties.targetResource.resourceType,error:properties.statusMessage}" \
            --output table
          
          exit 1
        fi
        
        echo "✅ Infrastructure deployment succeeded"
        
        # Verify critical resources are ready
        echo "Verifying deployed resources..."
        
        # Check App Service
        APP_STATE=$(az webapp show --resource-group ${{ vars.RESOURCE_GROUP }} --name ${{ vars.AZURE_WEBAPP_NAME }} --query "state" --output tsv)
        echo "App Service State: $APP_STATE"
        
        # Check Key Vault
        KV_STATE=$(az keyvault show --name ${{ vars.KEY_VAULT_NAME }} --query "properties.provisioningState" --output tsv)
        echo "Key Vault State: $KV_STATE"
        
        if [ "$KV_STATE" != "Succeeded" ]; then
          echo "::warning::Key Vault not ready yet, waiting 30 seconds for provisioning to complete..."
          sleep 30
        fi
        
    - name: Configure Key Vault secrets
      run: |
        echo "Configuring Key Vault secrets..."
        
        # Wait for Key Vault to be fully ready
        echo "Ensuring Key Vault access is available..."
        for i in {1..5}; do
          if az keyvault secret set \
            --vault-name ${{ vars.KEY_VAULT_NAME }} \
            --name "openai-api-key" \
            --value "${{ secrets.OPENAI_API_KEY }}" > /dev/null 2>&1; then
            echo "✅ OpenAI API key configured successfully"
            break
          else
            echo "Attempt $i/5: Key Vault not ready, waiting 10 seconds..."
            sleep 10
          fi
        done
        
        # Verify secret was set
        SECRET_CHECK=$(az keyvault secret show --vault-name ${{ vars.KEY_VAULT_NAME }} --name "openai-api-key" --query "id" --output tsv 2>/dev/null || echo "FAILED")
        if [ "$SECRET_CHECK" = "FAILED" ]; then
          echo "::error::Failed to configure Key Vault secrets"
          exit 1
        fi
        
    - name: Verify App Settings
      run: |
        echo "Verifying App Service settings..."
        az webapp config appsettings list \
          --resource-group ${{ vars.RESOURCE_GROUP }} \
          --name ${{ vars.AZURE_WEBAPP_NAME }} \
          --query "[].{name:name, value:value}" \
          --output table
        echo "✅ App settings verified"
        
    - name: Deploy to production
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ vars.AZURE_WEBAPP_NAME }}
        package: deploy.zip
        
    - name: Health check
      run: |
        echo "Waiting for app to start (60 seconds)..."
        sleep 60
        
        APP_URL="https://${{ vars.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        echo "Testing health endpoint at: $APP_URL/health"
        
        # Get detailed health check response
        HEALTH_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" "$APP_URL/health" || echo "CURL_FAILED")
        
        if [[ "$HEALTH_RESPONSE" == "CURL_FAILED" ]]; then
          echo "::error::Failed to connect to health endpoint"
          echo "Checking app service logs for startup issues..."
          
          # Get recent app service logs
          az webapp log tail --resource-group ${{ vars.RESOURCE_GROUP }} --name ${{ vars.AZURE_WEBAPP_NAME }} --provider application --num 50 || true
          exit 1
        fi
        
        # Extract HTTP status code
        HTTP_CODE=$(echo "$HEALTH_RESPONSE" | grep "HTTP_CODE:" | sed 's/HTTP_CODE://')
        HEALTH_JSON=$(echo "$HEALTH_RESPONSE" | head -n -1)
        
        echo "HTTP Status: $HTTP_CODE"
        echo "Health Response: $HEALTH_JSON"
        
        # Parse health status from JSON response
        HEALTH_STATUS=$(echo "$HEALTH_JSON" | jq -r '.status // "unknown"')
        
        echo "Application Status: $HEALTH_STATUS"
        
        if [[ "$HTTP_CODE" == "200" ]]; then
          if [[ "$HEALTH_STATUS" == "healthy" ]]; then
            echo "✅ Application is healthy and all checks passed"
          elif [[ "$HEALTH_STATUS" == "degraded" ]]; then
            echo "⚠️  Application is running but with issues:"
            echo "$HEALTH_JSON" | jq -r '.checks // {}' | jq 'to_entries[] | select(.value.status != "healthy") | "- \(.key): \(.value.message)"'
            
            # Continue deployment but warn about issues
            echo "::warning::Application deployed successfully but some health checks failed"
          else
            echo "::error::Application health check returned unexpected status: $HEALTH_STATUS"
            exit 1
          fi
        else
          echo "::error::Health check failed with HTTP $HTTP_CODE"
          echo "Response: $HEALTH_JSON"
          exit 1
        fi
        
    - name: Update Application Insights
      run: |
        az monitor app-insights component update \
          --app workbook-bot-insights \
          --resource-group ${{ vars.RESOURCE_GROUP }} \
          --set retentionInDays=90
      continue-on-error: true

  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Snyk security scan
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high
      continue-on-error: true
      
    - name: Dependency review
      uses: actions/dependency-review-action@v3
      if: github.event_name == 'pull_request'